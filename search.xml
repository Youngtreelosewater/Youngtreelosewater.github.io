<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/05/13/Games104-%E6%B8%B2%E6%9F%93/"/>
      <url>/2023/05/13/Games104-%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="引擎的渲染实践"><a href="#引擎的渲染实践" class="headerlink" title="引擎的渲染实践"></a>引擎的渲染实践</h1><ul><li><p>图形学一般不关注硬件实现，更注重算法以及数学的正确性</p><ul><li>30fps 实时&#x2F;10fps 可交互</li><li>离线</li></ul></li><li><p>Challenges</p><ul><li>各种各样的材质、大量的后处理、光照运算；非常复杂的组合 ALL in one</li><li>深度适配当代硬件</li><li>减少掉帧，保证每帧计算时间不超过一定值</li><li>可以吃满显卡，cpu只能占用10%~20%</li></ul></li><li><p>工程实践</p></li><li><p>内容</p><ul><li>Basics of game Render<ul><li>硬件</li><li>渲染数据的组织</li><li>可见性裁剪</li></ul></li><li>材质 shader 光照<ul><li>PBR（SG、MR）</li><li>shader模型</li><li>点光影、方向光；IBL、simple GI</li></ul></li><li>特殊<ul><li>地形</li><li>天空 云雾</li><li>后处理</li></ul></li><li>Pipline<ul><li>deferred 延迟、前向渲染</li><li>显卡提交屏幕，绘制内容的管理</li><li>Tiled-based rendering</li></ul></li></ul></li><li><p>游戏引擎设计与硬件架构设计密切相关</p></li><li><p>子网格设计用于支持多种材质的模型</p></li><li><p>使用剔除裁剪绘制尽可能少的对象</p></li><li><p>GPU驱动：随着GPU越来越强，将更多的工作移至GPU</p></li></ul><h2 id="渲染系统的对象"><a href="#渲染系统的对象" class="headerlink" title="渲染系统的对象"></a>渲染系统的对象</h2><ul><li>光栅化 顶点找到材质纹理计算光照等等最后成像素</li><li>绘制<ul><li>投影和光栅化</li><li>着色 shading<ul><li>constants 常量 parameters 变量</li><li>texture sampling<ul><li>Mipmap  （低频滤波）</li></ul></li></ul></li></ul></li></ul><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><p>专用硬件解决大量工作</p><ul><li>SIMD and SIMT<ul><li>SIMD 四个通道相加 同时处理四个数的加法</li><li>SIMT 几百个核</li></ul></li><li>CPU与GPU：几个博士和几千个小学生</li><li>重要的概念：做绘制算法、所有运算时，用同样的代码，让所有人一起跑，每个人访问自己的数据</li><li>GPU架构<ul><li>费米架构，新的安培，最新的光追架构</li><li>![[Pasted image 20230426174201.png]]</li><li>图形处理集群<ul><li>Streaming Multiprocessor <ul><li>处理非常耗时的纹理采样，以及复杂的数学计算（三角函数，PS：不求精度可以泰勒展开乘多项式）</li><li>NV的叫warp,AMD的叫weavrfront,power vr的叫usc；</li><li>stream multi processor是NV处理warp的东西</li></ul></li></ul></li></ul></li><li>CPU与GPU的数据流动有成本，高延迟，有限的带宽<ul><li>最好CPU单向传数据给GPU</li></ul></li><li>Cashe 缓存<ul><li>CPU从内存拿数据到缓存的时间周期，足够缓存的数据做上百次加法运算</li></ul></li></ul><h2 id="Mesh-Render-Component"><a href="#Mesh-Render-Component" class="headerlink" title="Mesh Render Component"></a>Mesh Render Component</h2><p>组件通过Renderable辨认</p><ul><li>绘制<ul><li>Mesh 表达 <ul><li>顶点：位置、颜色、UV、等<ul><li>三角形：每三个顶点组成三角形</li><li>索引存储<ul><li>三角形之间共用很多顶点，顶点数量只有三角形的一半，减少6倍以上的数据存储量</li><li>![[0}YAHFR4WYB%]B6S8)QN4_E.jpg]]</li><li>顶点存储到缓存里，对访问友好</li><li>每个顶点单独定义一个法线方向</li><li>![[Pasted image 20230426175907.png]]</li></ul></li></ul></li></ul></li><li>Material<ul><li>确定物体外观，光线与物体的交互</li><li>![[Pasted image 20230426180717.png]]</li><li>纹理</li><li>Shader<ul><li>即是源码，也是资产</li></ul></li><li>Texture</li></ul></li></ul></li><li>GO SubMesh<ul><li>根据材质切分Mesh，切成SubMesh</li><li>Mesh全部放在一个大Buffer，通过偏移确定</li><li>SubMesh的顶点</li><li>![[Pasted image 20230426181517.png]]</li></ul></li><li>优化 <ul><li>资源池，将shader、mesh、texture划分，索引</li><li>![[Pasted image 20230426182002.png]]</li></ul></li><li>实例化 合批<ul><li>将场景的物理依照材质进行排序，一次材质，绘制所有的submesh</li><li>GPU实例化<ul><li>当多数子物体一样，重复设置VB vertex Buffer 顶点buffer.、IB index buffer 索引buffer</li><li>Shader将一次drawCall，设置一次VB、IB，和绘制的位移数据，创建成百上千的物体</li></ul></li></ul></li></ul><h2 id="可见性裁剪"><a href="#可见性裁剪" class="headerlink" title="可见性裁剪"></a>可见性裁剪</h2><p>剔除与裁剪</p><ul><li>包围盒与视线锥<ul><li>包围盒 【AABB 仅存对角俩个端点，![[Pasted image 20230427111513.png]]</li><li>剔除用 四叉树与BVH （BVH常用，适用动态场景）![[Pasted image 20230427111905.png]]</li><li>PVS 【游戏引擎行业之父John Carmark发明的，利于资源的加载![[Pasted image 20230427112200.png]]</li><li>GPU Culling：不用精巧的算法，仅用GPU<ul><li>能用硬件，就用硬件</li><li>Early-Z，深度测试，先用深度绘制场景，挡住的像素跳过后面的渲染</li></ul></li></ul></li></ul><h2 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h2><p>![[Pasted image 20230427140734.png]]</p><ul><li>压缩思想：Block Compression![[Pasted image 20230427141151.png]]<ul><li>相邻像素之间的关联度，每个像素跟最亮值与最小值的比例关系</li><li>移动端的ASTC的压缩效率最好，解压缩也不低。但压缩运算太费，无法运行中进行压缩</li><li>分块压缩，采样只解压对应分块</li></ul></li></ul><h2 id="建模工具"><a href="#建模工具" class="headerlink" title="建模工具"></a>建模工具</h2><p>![[Pasted image 20230427142614.png]]</p><h2 id="模型管线"><a href="#模型管线" class="headerlink" title="模型管线"></a>模型管线</h2><ul><li>艺术家创作的模型细节越来越多<br>Cluster-Based Mesh Pipline![[Pasted image 20230427143149.png]]</li></ul><h1 id="渲染中，光与材质的数学魔法"><a href="#渲染中，光与材质的数学魔法" class="headerlink" title="渲染中，光与材质的数学魔法"></a>渲染中，光与材质的数学魔法</h1><p>![[Pasted image 20230428152612.png]]</p><ul><li>光的核心，光子<ul><li>emit 发射、bounce 反弹、absorb 吸收、perception 感知 是render的起源</li></ul></li><li>材质<ul><li>如何与光子产生物质反应</li></ul></li><li>Shader<ul><li>如何写以及复杂的运算</li></ul></li></ul><h2 id="The-Rendering-Equation"><a href="#The-Rendering-Equation" class="headerlink" title="The Rendering Equation"></a>The Rendering Equation</h2><p>Kajiya sig1986 提出的渲染方程![[Pasted image 20230428154313.png]]<br>看见的光子 &#x3D; 自发光 + 反射方程 * 接收的光强 * 光与法线的夹角<br>ira 进来的光 入射的能量、ra 出去的光 辐射出去的能量【黑体辐射<br>光可线性叠加</p><ul><li>Rendering Equation 的 Challenge</li><li>1nd 很难得到ira![[Pasted image 20230509145325.png]]</li><li>![[Pasted image 20230509145346.png]]<ul><li>阴影<ul><li>可见性折磨人，无法兼顾abcd</li></ul></li><li>复杂的光源 定向、点、聚、面</li></ul></li><li>2nd 拿到ira 做shading运算，积分运算![[Pasted image 20230509145303.png]]<ul><li>在球面函数上，把光与BRDF在一起积分，实时如何快速知道光与材质之间卷积的结果 知道整个球面的光，如何做出材质的表现也不简单</li></ul></li><li>3nd 第一步的Light Output 将作为下一次的Input 无限递归，又将1复杂化  ![[Pasted image 20230509145216.png]]<ul><li>所有物质都将成为光源</li></ul></li></ul><h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><ul><li><p>Simple Light Solution</p><ul><li>光源 大多数定向光，特殊用点与聚光灯</li><li>Ambient 用基础色</li><li>早期硬件支持</li><li>![[Pasted image 20230509150428.png]]</li></ul></li><li><p>Reflection </p><ul><li>环境贴图 cubeMap<br>![[Pasted image 20230509151024.png]]</li></ul></li><li><p>材质</p><ul><li>最前沿的涉及光的波动，经验派 Bling phone模型</li><li>bling phone模型的问题<ul><li>![[Pasted image 20230509152840.png]]离线渲染中会出大问题，能量保守(收敛)  Energy Conservative，能量不会守恒，因为光会被材质吸收</li><li>塑料质感，与PBR有差距</li></ul></li></ul></li><li><p>Shadow</p><ul><li>早期硬件不支持ShadowMap![[Pasted image 20230509153523.png]]</li><li>游戏过去二十年只用了ShadowMap<ul><li>光源渲染深度，相机对每个点 与深度图计算</li><li>![[Pasted image 20230509154930.png]]<ul><li>光源的深度图的采样率 与 相机的所看的点 采样率不一样</li><li>自遮挡，bias容差，阴影浮空 离脚</li><li>夕阳的采样率问题，用俩套算法，倾斜到一定角度后用算法b，其余用算法a</li></ul></li></ul></li></ul></li><li><p>![[Pasted image 20230509155745.png]]可以移动端以及游戏超低配</p></li></ul><h2 id="Pre-computed-Global-lllumination-预计算全局光照"><a href="#Pre-computed-Global-lllumination-预计算全局光照" class="headerlink" title="Pre-computed Global lllumination 预计算全局光照"></a>Pre-computed Global lllumination 预计算全局光照</h2><ul><li>5~10年前 AAA所用的技术</li><li>![[Pasted image 20230509160255.png]]<ul><li>Ambient直接提，让空间变得很平面</li></ul></li><li>全局光照 球面空间的采样<ul><li>如何Diffuse面与 球面光照算积分<ul><li>蒙特卡洛 往球面扔百个采样点 每个方向都算一下再积分一下</li><li>卷积运算 每个像素 Shading时与整个球面光照积分，做采样做累加</li></ul></li><li>快速积分 傅里叶变换<ul><li>循环信号 拆解成不同频率信号的累加</li><li>卷积运算</li></ul></li></ul></li><li>Spherical Harmonics<ul><li>![[Pasted image 20230509162945.png]]<ul><li>sin cos 函数集</li><li>0阶 将整个球面加权平均</li><li>一阶 xyz平方和为一，俩个自由度</li></ul></li><li>![[Pasted image 20230509163005.png]]<br>  * <ul><li>氢原子的电子轨道</li></ul></li><li>![[Pasted image 20230509183753.png]]<ul><li>light probe 所看见的光</li><li>低频 描述了光强</li></ul></li><li>![[Pasted image 20230509163759.png]]<ul><li>表达一个球状的光，需要12个参数，因为RGB通道3张图，一张图用一阶SH有4个参数</li><li>0阶 等同于 将整个环境光场做一次加权平均，因为现在游戏都是HDR，采取HDR压缩</li><li>后面的采用LDR的压缩</li><li>存一个RGBA 即为32Bits，用一个带Aphla的颜色空间，就能存每个点上的光场 高精度</li></ul></li><li>球面上俩个函数的卷积 简化成：俩个函数投影到SH的俩个参数，通过这俩个数的卷积 &#x3D; 结果</li></ul></li><li>LightMap 预计算GI<ul><li>最早用于计算Shadow，随着ShadowMap的发展，太土了就遗弃了</li><li>![[Pasted image 20230510134703.png]]</li><li>irradiance probe烘焙的</li><li>优势<ul><li>运行高效</li><li>因为离线bake，有soft的软阴影</li></ul></li><li>劣势<ul><li>长时间高耗的预计算</li><li>只有静态场景和静态灯光</li><li>封装和GPU的存储成本</li></ul></li><li>思想<ul><li>空间换时间</li><li>游戏场景转化为2维texture【甚至3维volume】可以做很多计算</li></ul></li></ul></li><li>Probes<ul><li>Light Probes <ul><li>动态物体加GI</li><li>精度低 数量多</li></ul></li><li>Reflection Probes<ul><li>精度高 数量少</li></ul></li><li>优势<ul><li>运行高效</li><li>同时处理静态与动态物体</li><li>处理漫反射与镜面反射的shading</li><li>现在计算机的优势，可以实时更新Light probe，<ul><li>判断是否变化，空闲时再更新，</li></ul></li></ul></li><li>劣势<ul><li>也需要预计算</li><li>没法实现GI的细节、soft shadow柔和阴影</li><li>采样率只有LightMap几百分之一</li></ul></li></ul></li></ul><h2 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h2><p>PBR 材质 光照 相机</p><ul><li>微表面理论 Microfacet Theory![[Pasted image 20230510140722.png]]<ul><li>镜面与粗糙</li></ul></li><li>BRDF模型![[Pasted image 20230510141240.png]]<ul><li>漫反射<ul><li>c&#x2F;π， c 为进来多少的能量</li></ul></li><li>镜面反射<ul><li>DFG，</li><li>D法线分布方程![[Pasted image 20230510141511.png]]<ul><li>高光的表达<ul><li>phone 突兀、GGX有渐变【音箱 高音脆 低音广</li></ul></li><li>粗糙度 越高 随机度越高</li></ul></li><li>G 微表面几何的内部遮挡![[Pasted image 20230510144249.png]]<ul><li>遮挡对光线与视线是等价的<ul><li>遮挡率为0.3 则最后到相机为 0.7 * 0.7 &#x3D; 0.49</li></ul></li><li>巧妙利用了D项引入的粗糙度</li></ul></li><li>F 菲涅尔![[Pasted image 20230510145518.png]]<ul><li>5次方 大牛推出来的</li></ul></li></ul></li><li>MERL 将现实物质推理出BRDF所需参数的设备![[Pasted image 20230510145907.png]]<ul><li>粗糙度 菲涅尔 diffuse</li></ul></li></ul></li><li>disney BRDF![[Pasted image 20230510150803.png]]<ul><li>![[Pasted image 20230510151746.png]]</li></ul></li><li>目前主流的规范<ul><li>SG![[Pasted image 20230510151906.png]]<ul><li>漫反射(金属颜色为黑)、Specular 反射贴图 f0、glossiness 光泽度【粗糙度<ul><li>Specular 艺术家设置不好会导致菲涅尔爆炸 f0</li></ul></li><li>![[Pasted image 20230510153619.png]]</li></ul></li><li>MR 在SG外部包装一下![[Pasted image 20230510154932.png]]<ul><li>非金属部分的f0为0.04</li></ul></li><li>MR<ul><li>优势<ul><li>较少纹理内存，MR都是灰度图</li><li>减少因为提供不正确的f0导致的错误，无法控制f0</li></ul></li><li>缺点<ul><li>白边，金属与非金属过渡时，分辨率</li></ul></li></ul></li><li>SG<ul><li>优势<ul><li>白边不明显</li><li>Specular 可以控制f0</li></ul></li><li>劣势<ul><li>影响f0</li><li>更多的内存</li></ul></li></ul></li></ul></li></ul><h2 id="IBL"><a href="#IBL" class="headerlink" title="IBL"></a>IBL</h2><ul><li>背光面与环境光的表达。CubeMap 表达四面八方的光照</li><li>核心思想：对光照做预处理，计算 整个环境对点的光照 和 材质的卷积<ul><li>SH太粗糙，只能有明暗的感觉</li></ul></li><li>BRDF的俩个Part 接受IBL</li><li>diffuse![[Pasted image 20230510162815.png]]</li><li>Specular![[Pasted image 20230510163317.png]]<ul><li>三个乘法的积分 变成 三个积分的乘法</li><li>粗糙度影响积分结果<ul><li>通过硬件的cubemap的Mipmap，将不同粗糙度接受的结果，存进Mipmap层级，需要单独算出来，存储光照![[Pasted image 20230510164042.png]]</li><li>通过一张LUT 输入粗糙度与角度跟环境的关系，决定Mipmap层级 存储transfer![[Pasted image 20230510164402.png]]</li></ul></li></ul></li><li>![[Pasted image 20230510164441.png]]</li></ul><h2 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h2><ul><li>CSM Cascade Shadow![[Pasted image 20230510165114.png]]<ul><li>级联阴影之间的混合<ul><li>级联重叠部分会有缝</li><li>因为级联之间分辨率不一致</li><li>shader根据像素在混合带的位置在俩个值进行线性插值</li></ul></li><li>假设绘制用了30ms，阴影计算会吃到4、5ms，很难做到2ms以下</li><li>优点<ul><li>快速生成深度图，3倍的开销</li><li>效果好</li><li>最好的解决shadow问题</li></ul></li><li>缺点<ul><li>没有彩色阴影，半透明物体透射出不透明的阴影</li><li>无法提供高质量的区域阴影</li></ul></li></ul></li><li>PCF、基于实战的PCSS![[Pasted image 20230510170352.png]]</li><li>VSSM![[Pasted image 20230510170510.png]]</li><li></li></ul><h2 id="Real-time-global-Illumination"><a href="#Real-time-global-Illumination" class="headerlink" title="Real time global Illumination"></a>Real time global Illumination</h2><p>![[Pasted image 20230510171144.png]]</p><p>![[Pasted image 20230510171351.png]]<br>![[Pasted image 20230510171732.png]]</p><h2 id="Shader-Manege"><a href="#Shader-Manege" class="headerlink" title="Shader Manege"></a>Shader Manege</h2><ul><li>大量的shader</li><li>通过宏定义 将一个大shader 拆成小shader，每一个变种都是一个分支<ul><li>点光源还是面光源，全局光照下，SH下，单双面渲染，带不带Alpha</li><li>分支会导致结束时间不一致，GPU使用simt架构希望时间一致<ul><li>将所有分支编译成大量shader![[Pasted image 20230510172244.png]]</li></ul></li><li>修改时只需要改大的，不用一个个改小的</li></ul></li><li>shader在不同平台的编译![[Pasted image 20230510172801.png]]</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>对对对</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>对对对</td><td>去去去</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/13/Games104-%E5%BC%95%E6%93%8E%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%95%B4%E4%BD%93Pipline/"/>
      <url>/2023/05/13/Games104-%E5%BC%95%E6%93%8E%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%95%B4%E4%BD%93Pipline/</url>
      
        <content type="html"><![CDATA[<h1 id="引擎分层架构与整体Pipline"><a href="#引擎分层架构与整体Pipline" class="headerlink" title="引擎分层架构与整体Pipline"></a>引擎分层架构与整体Pipline</h1><h2 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h2><ul><li>工具层 Tool<ul><li>编辑器</li></ul></li><li>功能层 Function<ul><li>可见的、可动的、可玩的</li></ul></li><li>资源层 Resource</li><li>核心层 Core</li><li>平台层 Platform</li></ul><p>![[Pasted image 20230412142648.png]]</p><h2 id="为什么分层？"><a href="#为什么分层？" class="headerlink" title="为什么分层？"></a>为什么分层？</h2><ul><li>![[Pasted image 20230412153628.png]]</li><li>解耦Decpling 降低复杂度Complexity<ul><li>下层 独立于上层</li><li>上层 不知道 下层 实现implemented</li></ul></li><li>接受需求时，只需动能层，底层稳定</li><li>tick：只允许上层调用下层</li></ul><h2 id="资源层"><a href="#资源层" class="headerlink" title="资源层"></a>资源层</h2><p>resource 到 Access</p><ul><li>给资源发放guid，资产的身份识别号</li><li>实时资产管理器<ul><li><strong>handle</strong> system</li></ul></li><li>生命周期管理<ul><li>GC 垃圾回收</li><li>延时加载</li></ul></li></ul><h2 id="功能层"><a href="#功能层" class="headerlink" title="功能层"></a>功能层</h2><p>内容最多<br>Ticks 周期</p><ul><li>一个Tick 处理所有该做的事情，运转所有的齿轮</li><li>tickMain 函数（可能不叫这名）<ul><li>Tick Logic 逻辑帧<ul><li>物理引擎</li></ul></li><li>Tick Render 渲染帧<ul><li>渲染引擎</li></ul></li></ul></li><li>多线程 一核有难，七核围观<ul><li>并行，先后顺序是难点</li><li>多核未来趋势  核心代码考虑多核</li></ul></li></ul><h2 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h2><p>数学库</p><ul><li>物理所用数学库非常高深，一般的简单<br>效率 Efficiency</li><li>倒数平方根 耗，用大致解</li><li>SIMD 单指令流多数据流<br>数据结构，为上层所有数据服务</li><li>![[Pasted image 20230412150820.png]]</li><li>Array 存数据；二叉树 查找等等</li><li>当超过存储空间，会倍数增长</li><li>追求访问效率，没有内存碎片<br>内存管理</li><li>![[Pasted image 20230412151852.png]]</li><li>Cpu的缓存，相同主频，cashe大，吞吐数据更快，</li><li>PMR 局部性原理<ul><li>C++等新功能的底层逻辑</li><li>把数据放一起</li><li>访问数据尽可能顺序访问</li><li>读写的时候 一起去读写</li></ul></li><li>CORE<ul><li>![[Pasted image 20230412152419.png]]</li><li>写Core 一般资深</li></ul></li></ul><h2 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h2><p>平台之间的图形库差异性</p><ul><li>![[Pasted image 20230412152702.png]]</li><li>引擎水平分水岭</li></ul><h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>编辑器</p><ul><li>效率<br>DCC Digital Content Creation</li><li>Asset Conditioning Pipeline  导出器与导入器</li></ul><h1 id="如何构建游戏世界"><a href="#如何构建游戏世界" class="headerlink" title="如何构建游戏世界"></a>如何构建游戏世界</h1><h2 id="如何让游戏世界活起来"><a href="#如何让游戏世界活起来" class="headerlink" title="如何让游戏世界活起来"></a>如何让游戏世界活起来</h2><ul><li>Game Object GO<ul><li>Dynamic game object 动态</li><li>Static game object 静态</li><li>Environment<ul><li>Terrain 地形</li><li>Sky 天空</li><li>Vegetation 植被</li></ul></li><li>Other game object<ul><li>Air wall</li><li>游戏规则</li><li></li></ul></li></ul></li><li>如何描述GO<ul><li>property 属性与 behavior 行为</li><li>派生、继承行为（面向对象）</li></ul></li><li>组件化<ul><li>鸟人继承鸟还是人？</li><li>组合代替继承</li><li>transform model AI 等</li><li>Components 组件 （UE：继承UObject  ）</li><li>![[Pasted image 20230425174554.png]]</li></ul></li><li>Tick 所有GO执行一遍<ul><li>Tick执行按照系统顺序</li><li>![[Pasted image 20230425175017.png]]</li></ul></li><li>消息系统 GO之间的通信（观察者模式）<ul><li>Event 事件机制：广播 </li><li>![[Pasted image 20230425175927.png]]</li></ul></li></ul><h2 id="如何管理游戏对象"><a href="#如何管理游戏对象" class="headerlink" title="如何管理游戏对象"></a>如何管理游戏对象</h2><ul><li>资源层使用guid；GO 使用ID + position<ul><li>小游戏的简单管理 &#x3D; 不管理；n平方</li></ul></li><li>场景管理<ul><li>八叉树，四叉树，根据GO数量</li><li>![[Pasted image 20230425180850.png]]</li><li>![[Pasted image 20230425181142.png]]</li><li></li></ul></li></ul><h2 id="其它需要处理的复杂情况"><a href="#其它需要处理的复杂情况" class="headerlink" title="其它需要处理的复杂情况"></a>其它需要处理的复杂情况</h2><ul><li>绑定 车与人<ul><li>tick的先后关系，先tick子物体，再tick父物体</li></ul></li><li>GO之间互相通信，会产生逻辑悖论<ul><li>确定性</li><li>精彩回放：记录输入，重新跑一遍游戏</li></ul></li></ul><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>tick过长<ul><li>跳过下一个tick，tick俩帧</li><li>当一个tick处理多个事件时，分批处理</li></ul></li><li>渲染线程与逻辑线程如何在tick同步<ul><li>tick各个GO的逻辑，tick渲染准备数据，多个线程准备渲染数据</li><li>输入显示延迟</li></ul></li><li>空间划分怎么处理动态GO</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/13/Games104-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E4%B8%8E%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
      <url>/2023/05/13/Games104-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E4%B8%8E%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="地形渲染"><a href="#地形渲染" class="headerlink" title="地形渲染"></a>地形渲染</h1><h2 id="地形几何"><a href="#地形几何" class="headerlink" title="地形几何"></a>地形几何</h2><ul><li>如何表达地图<ul><li>高度图【等高线图】、</li><li>Heightfield</li></ul></li><li>LOD FOV 三角形 近处密集 远处稀疏<ul><li>高倍镜 减低FOV</li><li>T-Junction<ul><li>![[Pasted image 20230511144050.png]]</li></ul></li><li>四叉树 更符合直觉<ul><li>![[Pasted image 20230511144310.png]]</li></ul></li><li>退化三角形<ul><li>![[Pasted image 20230511144706.png]]</li></ul></li></ul></li></ul><h3 id="gpu"><a href="#gpu" class="headerlink" title="gpu"></a>gpu</h3><ul><li><p>gpu完成几何的细化</p></li><li><p>![[Pasted image 20230511145706.png]]</p><ul><li>![[Pasted image 20230511145750.png]]<ul><li>HULL Shader<ul><li>生成一小块几何区域，有控制点可以控制凸凹</li><li>俩份数据，给Ctrol Point的数据、告诉TESSELLATOR拆了多少次</li></ul></li><li>TESSELLATOR </li><li>DOMAIN Shader<ul><li>采样高度图，移动顶点</li></ul></li></ul></li></ul></li><li><p>Mesh Shader</p><ul><li>干完了上述的GPU流程</li><li>DX12以上，win7不支持，win10以上</li></ul></li><li><p>动态地形</p><ul><li>雪地</li></ul></li></ul><h3 id="挖洞"><a href="#挖洞" class="headerlink" title="挖洞"></a>挖洞</h3><p>![[Pasted image 20230511151117.png]]</p><ul><li>将顶点设置为0，连接的三角面都没了</li><li>art再塞个隧道模型</li></ul><h3 id="体素化"><a href="#体素化" class="headerlink" title="体素化"></a>体素化</h3><ul><li>三维空间 每个点附有权重值![[Pasted image 20230511151558.png]]<ul><li>权重值表示有没有物质以及物质的密度</li></ul></li><li>![[Pasted image 20230511151749.png]]<ul><li>![[Pasted image 20230511152804.png]]<ul><li>地形使用会需要近处精度高，远处小</li></ul></li></ul></li></ul><h2 id="地形绘制"><a href="#地形绘制" class="headerlink" title="地形绘制"></a>地形绘制</h2><h3 id="材质混合"><a href="#材质混合" class="headerlink" title="材质混合"></a>材质混合</h3><p>![[Pasted image 20230511153059.png]]</p><ul><li>混合区域的过渡会有问题![[Pasted image 20230511153136.png]]<ul><li>过渡区域通过高度图做调整<ul><li>![[Pasted image 20230511153238.png]]</li><li>相机移动过程，远处看较低视角看，会锐利，高频信息，会有扰动</li></ul></li><li>增加一个Bias<ul><li>![[Pasted image 20230511153355.png]]</li><li>通过这个权重做一个颜色插值，效果更稳定</li></ul></li></ul></li></ul><h3 id="Texture-Array"><a href="#Texture-Array" class="headerlink" title="Texture Array"></a>Texture Array</h3><p>![[Pasted image 20230511153832.png]]</p><ul><li>3D Texture<ul><li>通过八个顶点，三线性插值</li></ul></li><li>Texture Array<ul><li>权重以及index（标注了重叠材质的索引）</li></ul></li><li>相比材质混合，可以容纳更多层</li></ul><h3 id="视差与位移"><a href="#视差与位移" class="headerlink" title="视差与位移"></a>视差与位移</h3><p>Parallx and Displacement</p><ul><li>视差<ul><li>几何边界无变</li><li>ray maything 会比较耗</li></ul></li><li>位移<ul><li>GPU</li></ul></li></ul><h3 id="虚拟纹理"><a href="#虚拟纹理" class="headerlink" title="虚拟纹理"></a>虚拟纹理</h3><p>![[Pasted image 20230511155002.png]]</p><ul><li>早期的采样<ul><li>每个像素 十几张texture采样一遍，再加减乘除混合运算</li><li>bilinear 3次，但要选2级miimap后再差值，所以3 * 2+1&#x3D;7</li></ul></li><li>Virtual Texture<ul><li>![[Pasted image 20230511155438.png]]<ul><li>内存存放需要的，不需要的放进硬盘，虚拟内存交换【多层页表】</li></ul></li></ul></li><li>硬件技术<br>![[Pasted image 20230511161054.png]]</li><li>DirectStorage<ul><li>GPU做压缩工作，而非内存解压<ul><li>硬盘到内存到显卡，数据都是压缩的，速度快</li></ul></li></ul></li><li>DMA<ul><li>索尼大法，从硬盘直接到显存，不过CPU</li></ul></li><li>NV link<ul><li>GPU之间交换数据，以前需要经过内存，现在直接转移</li></ul></li></ul><h3 id="浮点数精度溢出"><a href="#浮点数精度溢出" class="headerlink" title="浮点数精度溢出"></a>浮点数精度溢出</h3><p>当地图越做越大<br>![[Pasted image 20230511161734.png]]</p><ul><li>![[Pasted image 20230511161853.png]]<ul><li>当窗帘与墙之间只有0.05毫米，俩公里之外，会互相穿插</li></ul></li><li>相机相对性渲染<ul><li>将距离变成离相机的位置</li></ul></li></ul><h3 id="Decorator-Rendering"><a href="#Decorator-Rendering" class="headerlink" title="Decorator Rendering"></a>Decorator Rendering</h3><pre><code>* 草 石头</code></pre><h3 id="树木"><a href="#树木" class="headerlink" title="树木"></a>树木</h3><ul><li>Speed tree</li></ul><h3 id="道路与贴花"><a href="#道路与贴花" class="headerlink" title="道路与贴花"></a>道路与贴花</h3><p>Road and Decals Rendering<br>![[Pasted image 20230511164012.png]]</p><ul><li>道路与decal的贴图<ul><li>一股脑 bake进虚拟纹理</li><li>runtime消耗低，</li></ul></li></ul><h1 id="天空与大气"><a href="#天空与大气" class="headerlink" title="天空与大气"></a>天空与大气</h1><h2 id="大气散射理论"><a href="#大气散射理论" class="headerlink" title="大气散射理论"></a>大气散射理论</h2><h3 id="简易大气散射模型"><a href="#简易大气散射模型" class="headerlink" title="简易大气散射模型"></a>简易大气散射模型</h3><p>![[Pasted image 20230511164723.png]]</p><ul><li>模型只要俩个参数，视线与天顶的夹角，视线与光线的夹角<ul><li>简单高效</li><li>无法实现从太空看过来的效果</li><li>参数固定，无法实现下雨天</li></ul></li></ul><h3 id="Participating-Media"><a href="#Participating-Media" class="headerlink" title="Participating Media"></a>Participating Media</h3><p>![[Pasted image 20230512140316.png]]</p><ul><li>空气漂浮的各种物质<ul><li>介质</li></ul></li><li>光如何与介质发生反应![[Pasted image 20230512140423.png]]<ul><li>辐射传递方程 RTF<ul><li>吸收 吸收常数</li><li>光打中介质，散射Out-scattering；散射系数<ul><li>跟光的方向有关系</li></ul></li><li>自发光 <ul><li>火焰、闪电，可不加</li></ul></li><li>来自周围的光<ul><li>球面上的光的积分</li></ul></li><li>图为一维方程，本为梯度方程，表示一个梯度，对梯度的积分&#x3D;VRE</li></ul></li></ul></li><li>VRE   构成光的现象 等同于RTE的积分![[Pasted image 20230512141307.png]]<ul><li>路径积分</li><li>Transmittance ： 远处的点最后到眼睛的部分</li><li>光经过散射、吸收 最后到眼睛的部分</li></ul></li></ul><h3 id="真实大气物理学"><a href="#真实大气物理学" class="headerlink" title="真实大气物理学"></a>真实大气物理学</h3><p>![[Pasted image 20230512142034.png]]</p><ul><li><p>太阳</p><ul><li>不同波长的光，</li></ul></li><li><p>大气</p><ul><li>气体分子，一般小于光的波长</li><li>气溶胶分子，接近光的波长</li></ul></li><li><p>散射模型![[Pasted image 20230512142257.png]]</p></li><li><p>Rayleigh 瑞利散射</p><ul><li>气体分子小于波长，将光均匀散射</li><li>越短波长散射越厉害【蓝紫光】</li></ul></li><li><p>Mie 米氏散射</p><ul><li>气溶胶 光的方向会略强，对波长不敏感</li></ul></li></ul><h3 id="Rayleigh-瑞利散射"><a href="#Rayleigh-瑞利散射" class="headerlink" title="Rayleigh 瑞利散射"></a>Rayleigh 瑞利散射</h3><p>![[Pasted image 20230512142726.png]]</p><ul><li>光散射 花生形状</li><li>短波蓝光散射强，长波红光散射弱<br>![[Pasted image 20230512143339.png]]</li><li>Rayleigh Scattering Equation<ul><li>geometry：花生形状 $\theta$ 为光的夹角</li><li>wavelength：1&#x2F;光的波长四次方 $\lambda$ 光的波长</li><li>Density：h 海拔高度、N 标准单位体积的空气密度<ul><li>当给定了海拔与空气密度，散射系数等于常数</li><li>只于Phase function的角度有关</li></ul></li></ul></li><li>![[Pasted image 20230512163406.png]]</li></ul><h3 id="Mie-米氏散射"><a href="#Mie-米氏散射" class="headerlink" title="Mie 米氏散射"></a>Mie 米氏散射</h3><p>![[Pasted image 20230512163608.png]]</p><ul><li>Mie散射方程Phase Fun分母错了，1+g^2-2gcosθ</li><li>拟合方程，g &#x3D; 0时，Phase Function类似瑞利散射的花生形状；当g&gt;1时，趋向这个形状；&lt;1时，往光的方向散射</li><li>art 调整 g参数</li></ul><p>![[Pasted image 20230512170032.png]]</p><ul><li>雾 水珠 气溶胶</li></ul><h3 id="吸收"><a href="#吸收" class="headerlink" title="吸收"></a>吸收</h3><ul><li>臭氧 甲烷 吸收长波<ul><li>假设均匀的分布在星球</li></ul></li></ul><h3 id="多次散射"><a href="#多次散射" class="headerlink" title="多次散射"></a>多次散射</h3><p>![[Pasted image 20230512171041.png]]</p><ul><li>single ：大气粒子散射太阳光到视线方向的能量的加和</li><li>Multiple ：视线途径外的粒子还会将光传递到视线方向</li><li>![[Pasted image 20230512171823.png]]</li></ul><h3 id="Ray-Marching"><a href="#Ray-Marching" class="headerlink" title="Ray Marching"></a>Ray Marching</h3><p>![[Pasted image 20230512171952.png]]</p><ul><li>沿着视线，均匀采点，计算太阳照到点的强度与方向，根据散射方程算瑞利与Mie，计算投向视线的光度，沿路积分下去</li><li>根据Ray Marching，预计算存表，根据视线方向，太阳角度查表</li></ul><h3 id="Precomputed-Atmospheric-Scattering"><a href="#Precomputed-Atmospheric-Scattering" class="headerlink" title="Precomputed Atmospheric Scattering"></a>Precomputed Atmospheric Scattering</h3><ul><li>最重要的俩点<ul><li>Transmittance：通透度，目标点到眼睛颜色剩多少</li><li>Scattering：到视线的散射度</li></ul></li></ul><h4 id="Transmittance-LUT"><a href="#Transmittance-LUT" class="headerlink" title="Transmittance LUT"></a>Transmittance LUT</h4><p>![[Pasted image 20230512173510.png]]</p><ul><li>计算通透度<ul><li>不需要太阳</li><li>对每个海拔高度，预存  $\theta$  视线与天顶的夹角，一路到大气层（比地球半径多100公里的地方）的通透度，</li><li>Xm的通透度： Xm到B的通透度 &#x2F; Xv到B的通透度 ；<ul><li>Xm到B的通透度 应该可以用 俩者距离的比例</li></ul></li></ul></li></ul><h4 id="Scattering-LUT"><a href="#Scattering-LUT" class="headerlink" title="Scattering LUT"></a>Scattering LUT</h4><p> ![[Pasted image 20230512182003.png]]</p><ul><li>计算<ul><li>难度：整个3D空间，太阳方向，视线方向</li><li>参数化<ul><li>选定海拔高度，<ul><li>视线到天顶的角；光照方向到天顶的角度；光照方向与视线的角度</li></ul></li></ul></li><li>存了一张四维的LUT</li></ul></li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>![[Pasted image 20230512182616.png]]</p><ul><li>拥有通透度、单次散射的图<ul><li>3到4次</li></ul></li><li>没听懂多次散射</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="实时大气渲染"><a href="#实时大气渲染" class="headerlink" title="实时大气渲染"></a>实时大气渲染</h1><h2 id="云的渲染"><a href="#云的渲染" class="headerlink" title="云的渲染"></a>云的渲染</h2><h2 id="pilot"><a href="#pilot" class="headerlink" title="pilot"></a>pilot</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第1篇博客</title>
      <link href="/2023/03/08/abc/"/>
      <url>/2023/03/08/abc/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>`&#96;&#96;<br>代码测试<br>`&#96;&#96;</p><p><br>代码测试<br>\</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码测试</span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><ul><li>1</li><li>2</li><li>3</li></ul><p><em>斜体</em></p><p><strong>粗体</strong></p><p>三连</p><p><img src="/_posts/image/Pasted%20image%2020230513233914.png"><br><img src="/images/Pasted%20image%2020230513232746.png"><img src="/_posts/image/Pasted%20image%2020230513233914.png"><br><img src="/movie/Pasted%20image%2020230513232157.png"></p>]]></content>
      
      
      <categories>
          
          <category> test categories分类 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
